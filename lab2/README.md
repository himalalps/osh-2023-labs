# 实验二：简易shell

## 目录导航

1. `pwd`命令，使用`getcwd`函数即可，其函数原型为
```C
char* getcwd(char *buf, size_t size);
```
如果`size`过小或是获取目录失败，则返回`NULL`，否则返回`buf`.只需正确获得`buf`然后输出即可.

2. `cd`命令，使用`chdir`命令，其函数原型为
```C
int chdir(const char *path);
```
需要对`args`进行错误判断，假如有多余的参数，需要报错.同时注意到`~`的扩展也是在shell中进行的，需要利用`getenv`函数获取`HOME`环境变量的值，同时假如`getenv("HOME")`失败，也需要进行错误处理，一种方式是使用`getpwuid`这样返回的`passwd`结构体中的`pw_dir`对应的就是当前用户的家目录.

3. `cd`无参数，直接返回`home`，获取`home`方式见2.

## 管道

1. 当有`pipe_num`个`|`时，代表有`pipe_num+1`个进程，需要创建`pipe_num`个管道，每个管道有两个文件描述符`fd`，使用二维数组`pipefd[pipe_num][2]`来存储对应的文件描述符，每个`pipefd[i][0]`对应读端，`pipefd[i][1]`对应写端.使用`fork`生成`pipe_num+1`个子进程，并使用`dup2`重定向，使用`execvp`执行对应的命令，之后由父进程将多余的`fd`用`close`关闭.

2. 注意因为已经每个子进程对应一个`fork`，需要将前面的`fork`移到非管道的情况下，否则会多出一层shell.

## 重定向

O_RDONLY 以只读方式打开文件
O_WRONLY 以只写方式打开文件
O_RDWR 以可读写方式打开文件. 上述三种旗标是互斥的, 也就是不可同时使用, 但可与下列的旗标利用OR(|)运算符组合.
O_CREAT 若欲打开的文件不存在则自动建立该文件.
O_EXCL 如果O_CREAT 也被设置, 此指令会去检查文件是否存在. 文件若不存在则建立该文件, 否则将导致打开文件错误. 此外, 若O_CREAT 与O_EXCL 同时设置, 并且欲打开的文件为符号连接, 则会打开文件失败.
O_NOCTTY 如果欲打开的文件为终端机设备时, 则不会将该终端机当成进程控制终端机.
O_TRUNC 若文件存在并且以可写的方式打开时, 此旗标会令文件长度清为0, 而原来存于该文件的资料也会消失.
O_APPEND 当读写文件时会从文件尾开始移动, 也就是所写入的数据会以附加的方式加入到文件后面.
O_NONBLOCK 以不可阻断的方式打开文件, 也就是无论有无数据读取或等待, 都会立即返回进程之中.
O_NDELAY 同O_NONBLOCK.
O_SYNC 以同步的方式打开文件.
O_NOFOLLOW 如果参数pathname 所指的文件为一符号连接, 则会令打开文件失败.
O_DIRECTORY 如果参数pathname 所指的文件并非为一目录, 则会令打开文件失败

S_IRWXU00700 权限, 代表该文件所有者具有可读、可写及可执行的权限.
S_IRUSR 或S_IREAD, 00400 权限, 代表该文件所有者具有可读取的权限.
S_IWUSR 或S_IWRITE, 00200 权限, 代表该文件所有者具有可写入的权限.
S_IXUSR 或S_IEXEC, 00100 权限, 代表该文件所有者具有可执行的权限.
S_IRWXG 00070 权限, 代表该文件用户组具有可读、可写及可执行的权限.
S_IRGRP 00040 权限, 代表该文件用户组具有可读的权限.
S_IWGRP 00020 权限, 代表该文件用户组具有可写入的权限.
S_IXGRP 00010 权限, 代表该文件用户组具有可执行的权限.
S_IRWXO 00007 权限, 代表其他用户具有可读、可写及可执行的权限.
S_IROTH 00004 权限, 代表其他用户具有可读的权限
S_IWOTH 00002 权限, 代表其他用户具有可写入的权限.
S_IXOTH 00001 权限, 代表其他用户具有可执行的权限.

## 拓展功能

1. 支持`$`扩展，获取环境变量，使用了`getenv`函数.