# 实验二：简易shell

## 选做内容

1. `cd`在没有第二个参数时，默认进入家目录.
2. 支持数字文件描述符.
3. 支持文本重定向.
4. 支持 `CTRL-D`.
5. `~`扩展，如`echo ~root`.
6. `$`扩展，如`echo $SHELL`.

## 目录导航

1. `pwd`命令，使用`getcwd`函数即可，其函数原型为
```C
char* getcwd(char *buf, size_t size);
```
如果`size`过小或是获取目录失败，则返回`NULL`，否则返回`buf`.只需正确获得`buf`然后输出即可.

2. `cd`命令，使用`chdir`命令，其函数原型为
```C
int chdir(const char *path);
```
需要对`args`进行错误判断，假如有多余的参数，需要报错.同时注意到`~`的扩展也是在shell中进行的，需要利用`getenv`函数获取`HOME`环境变量的值，同时假如`getenv("HOME")`失败，也需要进行错误处理，一种方式是使用`getpwuid`这样返回的`passwd`结构体中的`pw_dir`对应的就是当前用户的家目录.

3. `cd`无参数，直接返回`home`，获取`home`方式见2.

## 管道

1. 当有`pipe_num`个`|`时，代表有`pipe_num+1`个进程，需要创建`pipe_num`个管道，每个管道有两个文件描述符`fd`，使用二维数组`pipefd[pipe_num][2]`来存储对应的文件描述符，每个`pipefd[i][0]`对应读端，`pipefd[i][1]`对应写端.使用`fork`生成`pipe_num+1`个子进程，并使用`dup2`重定向，使用`execvp`执行对应的命令，之后由父进程将多余的`fd`用`close`关闭.

2. 注意因为已经每个子进程对应一个`fork`，需要将前面的`fork`移到非管道的情况下，否则会多出一层shell.

## 重定向

1. 为便于实现重定向，对程序进行了重构，对参数的处理移到`exec`函数中处理，同时在`exec`函数开始先处理重定向的部分.

2. 重定向需要根据命令中的`<`，`>`和`>>`选择不同的`open`函数`flag`参数，然后使用`dup2`函数将标准输入输出重定向即可.

3. 使用的`flag`参数列举如下
   - `O_RDONLY`只读模式打开，`O_CREAT`如果没有则创建，`O_WRONLY`只写模式打开，`O_APPEND`在原文件末尾添加，`O_TRUNC`覆盖原文件.
   - `S_IRUSR`，`S_IRGRP`，`S_IROTH`分别是所有者、用户组和其他用户拥有可读权限，`S_IWUSR`，`S_IWGRP`，`S_IWOTH`分别是所有者、用户组和其他用户拥有可写权限.
  
4. 实现了数字文件描述符重定向和文本重定向，文本重定向使用了`mkstemp`和`unlink`函数，分别用于临时文件打开和之后的自动删除.

## 信号处理

1. 使用`setpgrp`和`setpgid`函数将子进程组分离，用于之后的信号处理.

2. 使用`tcsetpgrp`函数选择前台进程组，为了防止shell被挂起，需要用`signal`函数忽略`SIGTTOU`信号.

3. 处理`CTRL-C`带来的`SIGINT`信号，使用自定义的`signal`函数，输出空行以及开头的提示符.

## 前后台进程

1. 为了方便之后的内建命令`wait`，将所有的后台进程存入`bg_jobs`.

2. 每次循环需要清除僵尸进程，使用`waitpid`，选择`option=WNOHANG`，如果等待的进程已经结束，则返回非零值，将该进程移除.
